<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>EDPL-OMPL: FIRM Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EDPL-OMPL
   &#160;<span id="projectnumber">0.4</span>
   </div>
   <div id="projectbrief">BeliefSpacePlannningbyEstimationDecisionandPlanningLab@TAMU</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_f_i_r_m-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FIRM Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Feedback Information RoadMap planner.  
 <a href="class_f_i_r_m.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_f_i_r_m_8h_source.html">FIRM.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FIRM:</div>
<div class="dyncontent">
<div class="center"><img src="class_f_i_r_m__inherit__graph.png" border="0" usemap="#_f_i_r_m_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for FIRM:</div>
<div class="dyncontent">
<div class="center"><img src="class_f_i_r_m__coll__graph.png" border="0" usemap="#_f_i_r_m_coll__map" alt="Collaboration graph"/></div>
<map name="_f_i_r_m_coll__map" id="_f_i_r_m_coll__map">
<area shape="rect" id="node3" href="class_n_b_m3_p.html" title="NBM3P" alt="" coords="169,5,236,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a687e9f4243b22c30ee1fa5da22a85053"><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list<br class="typebreak"/>
&lt; boost::vecS, boost::vecS, <br class="typebreak"/>
boost::bidirectionalS, <br class="typebreak"/>
boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a>, <br class="typebreak"/>
ompl::base::State <br class="typebreak"/>
*, boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a>, <br class="typebreak"/>
unsigned int, boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a>, <br class="typebreak"/>
unsigned int, boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a>, unsigned int, <br class="typebreak"/>
boost::property<br class="typebreak"/>
&lt; boost::vertex_predecessor_t, <br class="typebreak"/>
unsigned long int, <br class="typebreak"/>
boost::property<br class="typebreak"/>
&lt; boost::vertex_rank_t, <br class="typebreak"/>
unsigned long int &gt;<br class="typebreak"/>
 &gt; &gt; &gt; &gt; &gt;, boost::property<br class="typebreak"/>
&lt; boost::edge_weight_t, <br class="typebreak"/>
<a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a>, boost::property<br class="typebreak"/>
&lt; boost::edge_index_t, <br class="typebreak"/>
unsigned int, boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a>, unsigned int &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a></td></tr>
<tr class="memdesc:a687e9f4243b22c30ee1fa5da22a85053"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying roadmap graph.  <a href="#a687e9f4243b22c30ee1fa5da22a85053">More...</a><br/></td></tr>
<tr class="separator:a687e9f4243b22c30ee1fa5da22a85053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eb05796ed64797c900b193aafa9031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07eb05796ed64797c900b193aafa9031"></a>
typedef boost::graph_traits<br class="typebreak"/>
&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &gt;::vertex_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr class="separator:a07eb05796ed64797c900b193aafa9031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88889998bf429572821d467eb44c67c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88889998bf429572821d467eb44c67c6"></a>
typedef boost::graph_traits<br class="typebreak"/>
&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &gt;::edge_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr class="separator:a88889998bf429572821d467eb44c67c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52259e46a3f9a92099bf0b66af26a52c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52259e46a3f9a92099bf0b66af26a52c"></a>
typedef std::shared_ptr<br class="typebreak"/>
&lt; ompl::NearestNeighbors<br class="typebreak"/>
&lt; Vertex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RoadmapNeighbors</b></td></tr>
<tr class="separator:a52259e46a3f9a92099bf0b66af26a52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c6f3351c41a0416524ab2e01388e03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14c6f3351c41a0416524ab2e01388e03"></a>
typedef std::function<br class="typebreak"/>
&lt; std::vector&lt; Vertex &gt;<br class="typebreak"/>
 &amp;(const Vertex)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a14c6f3351c41a0416524ab2e01388e03">ConnectionStrategy</a></td></tr>
<tr class="memdesc:a14c6f3351c41a0416524ab2e01388e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function returning the milestones that should be attempted to connect to. <br/></td></tr>
<tr class="separator:a14c6f3351c41a0416524ab2e01388e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70abcb24fbc9f836b94119f65c8f8a37"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_controller.html">Controller</a>&lt; <a class="el" href="class_r_h_c_i_create.html">RHCICreate</a>, <br class="typebreak"/>
<a class="el" href="class_extended_k_f.html">ExtendedKF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">EdgeControllerType</a></td></tr>
<tr class="separator:a70abcb24fbc9f836b94119f65c8f8a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf37596ffd4dbf633d7cd0f27347d15c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf37596ffd4dbf633d7cd0f27347d15c"></a>
typedef <a class="el" href="class_controller.html">Controller</a>&lt; <a class="el" href="class_r_h_c_i_create.html">RHCICreate</a>, <br class="typebreak"/>
<a class="el" href="class_linearized_k_f.html">LinearizedKF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeControllerType</b></td></tr>
<tr class="separator:adf37596ffd4dbf633d7cd0f27347d15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a451aef223259f497ec178ad8447d04d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a451aef223259f497ec178ad8447d04d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a451aef223259f497ec178ad8447d04d5">FIRM</a> (const firm::SpaceInformation::SpaceInformationPtr &amp;si, bool debugMode=false)</td></tr>
<tr class="memdesc:a451aef223259f497ec178ad8447d04d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr class="separator:a451aef223259f497ec178ad8447d04d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a7ff97d8202a82ca7f6dddfd7ba185"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09a7ff97d8202a82ca7f6dddfd7ba185"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setProblemDefinition</b> (const ompl::base::ProblemDefinitionPtr &amp;pdef)</td></tr>
<tr class="separator:a09a7ff97d8202a82ca7f6dddfd7ba185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8017d1847e682f39c2cbce33e904af57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8017d1847e682f39c2cbce33e904af57">setConnectionStrategy</a> (const <a class="el" href="class_f_i_r_m.html#a14c6f3351c41a0416524ab2e01388e03">ConnectionStrategy</a> &amp;connectionStrategy)</td></tr>
<tr class="memdesc:a8017d1847e682f39c2cbce33e904af57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the connection strategy function that specifies the milestones that connection attempts will be made to for a given milestone.  <a href="#a8017d1847e682f39c2cbce33e904af57">More...</a><br/></td></tr>
<tr class="separator:a8017d1847e682f39c2cbce33e904af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a87b6c094c21b956a469a2b69cd387c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a87b6c094c21b956a469a2b69cd387c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2a87b6c094c21b956a469a2b69cd387c">setMaxNearestNeighbors</a> (unsigned int k)</td></tr>
<tr class="memdesc:a2a87b6c094c21b956a469a2b69cd387c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that sets the connection strategy to the default one with k nearest neighbors. <br/></td></tr>
<tr class="separator:a2a87b6c094c21b956a469a2b69cd387c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2e6a8c5dac3a0629f1dd0ac2313b9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f2e6a8c5dac3a0629f1dd0ac2313b9c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a5f2e6a8c5dac3a0629f1dd0ac2313b9c">constructRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr class="memdesc:a5f2e6a8c5dac3a0629f1dd0ac2313b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">While the termination condition allows, this function will construct the roadmap (using <a class="el" href="class_f_i_r_m.html#a947186c6e6be0b513efe0e0b476fef88" title="If the user desires, the roadmap can be improved for the given time (seconds). The solve() method wil...">growRoadmap()</a> and <a class="el" href="class_f_i_r_m.html#ad9cd5472a8bd1b1fcb83763128f7fd75" title="Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansio...">expandRoadmap()</a>, maintaining a 2:1 ratio for growing/expansion of roadmap) <br/></td></tr>
<tr class="separator:a5f2e6a8c5dac3a0629f1dd0ac2313b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947186c6e6be0b513efe0e0b476fef88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a947186c6e6be0b513efe0e0b476fef88"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a947186c6e6be0b513efe0e0b476fef88">growRoadmap</a> (double growTime)</td></tr>
<tr class="memdesc:a947186c6e6be0b513efe0e0b476fef88"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user desires, the roadmap can be improved for the given time (seconds). The <a class="el" href="class_f_i_r_m.html#a02f3c98de4840594193ba5bf7ff3ca63" title="The key function that solves the planning problem. ">solve()</a> method will also improve the roadmap, as needed. <br/></td></tr>
<tr class="separator:a947186c6e6be0b513efe0e0b476fef88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e741b0af39a64d34dcfa4f29c0e509"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8e741b0af39a64d34dcfa4f29c0e509"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae8e741b0af39a64d34dcfa4f29c0e509">growRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr class="memdesc:ae8e741b0af39a64d34dcfa4f29c0e509"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user desires, the roadmap can be improved until a given condition is true. The <a class="el" href="class_f_i_r_m.html#a02f3c98de4840594193ba5bf7ff3ca63" title="The key function that solves the planning problem. ">solve()</a> method will also improve the roadmap, as needed. <br/></td></tr>
<tr class="separator:ae8e741b0af39a64d34dcfa4f29c0e509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cd5472a8bd1b1fcb83763128f7fd75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9cd5472a8bd1b1fcb83763128f7fd75"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad9cd5472a8bd1b1fcb83763128f7fd75">expandRoadmap</a> (double expandTime)</td></tr>
<tr class="memdesc:ad9cd5472a8bd1b1fcb83763128f7fd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansion step) for the given time (seconds). <br/></td></tr>
<tr class="separator:ad9cd5472a8bd1b1fcb83763128f7fd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac520fbbb43b0e3100498aa29117f0b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac520fbbb43b0e3100498aa29117f0b9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aac520fbbb43b0e3100498aa29117f0b9">expandRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr class="memdesc:aac520fbbb43b0e3100498aa29117f0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansion step) until the given condition evaluates true. <br/></td></tr>
<tr class="separator:aac520fbbb43b0e3100498aa29117f0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f3c98de4840594193ba5bf7ff3ca63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02f3c98de4840594193ba5bf7ff3ca63"></a>
virtual ompl::base::PlannerStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a02f3c98de4840594193ba5bf7ff3ca63">solve</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr class="memdesc:a02f3c98de4840594193ba5bf7ff3ca63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The key function that solves the planning problem. <br/></td></tr>
<tr class="separator:a02f3c98de4840594193ba5bf7ff3ca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7c24814ea6b8cad9cad350dea66560"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7c24814ea6b8cad9cad350dea66560"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearQuery</b> (void)</td></tr>
<tr class="separator:acf7c24814ea6b8cad9cad350dea66560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5298e85713c7a736d6b8936f7171af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe5298e85713c7a736d6b8936f7171af"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> (void)</td></tr>
<tr class="separator:afe5298e85713c7a736d6b8936f7171af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd7c5ed3fa065f5f37d79bc1d220474"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8dd7c5ed3fa065f5f37d79bc1d220474"></a>
template&lt;template&lt; typename T &gt; class NN&gt; </td></tr>
<tr class="memitem:a8dd7c5ed3fa065f5f37d79bc1d220474"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8dd7c5ed3fa065f5f37d79bc1d220474">setNearestNeighbors</a> (void)</td></tr>
<tr class="memdesc:a8dd7c5ed3fa065f5f37d79bc1d220474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a different nearest neighbors datastructure. <br/></td></tr>
<tr class="separator:a8dd7c5ed3fa065f5f37d79bc1d220474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c43a180deb28296e4cab5c6939c600"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c43a180deb28296e4cab5c6939c600"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> (void)</td></tr>
<tr class="separator:a78c43a180deb28296e4cab5c6939c600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad0b0dfc1413f78c6dc76fdbac9ce7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacad0b0dfc1413f78c6dc76fdbac9ce7"></a>
const <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getRoadmap</b> (void) const </td></tr>
<tr class="separator:aacad0b0dfc1413f78c6dc76fdbac9ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a98fdb0da781d77fe6ff9a55e8a7a34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a98fdb0da781d77fe6ff9a55e8a7a34"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a9a98fdb0da781d77fe6ff9a55e8a7a34">distanceFunction</a> (const Vertex a, const Vertex b) const </td></tr>
<tr class="memdesc:a9a98fdb0da781d77fe6ff9a55e8a7a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two milestones (this is simply distance between the states of the milestones) <br/></td></tr>
<tr class="separator:a9a98fdb0da781d77fe6ff9a55e8a7a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558fbb0135ab096d3cd06e65b88533de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a558fbb0135ab096d3cd06e65b88533de"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a558fbb0135ab096d3cd06e65b88533de">milestoneCount</a> (void) const </td></tr>
<tr class="memdesc:a558fbb0135ab096d3cd06e65b88533de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two milestones (this is simply distance between the states of the milestones) <br/></td></tr>
<tr class="separator:a558fbb0135ab096d3cd06e65b88533de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6df82888d88ab8479f92f9f3e453c2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6df82888d88ab8479f92f9f3e453c2e"></a>
const RoadmapNeighbors &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad6df82888d88ab8479f92f9f3e453c2e">getNearestNeighbors</a> (void)</td></tr>
<tr class="memdesc:ad6df82888d88ab8479f92f9f3e453c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nearest neighbor structure. <br/></td></tr>
<tr class="separator:ad6df82888d88ab8479f92f9f3e453c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae448791d4c9af9016bc9d5e9de166f0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae448791d4c9af9016bc9d5e9de166f0e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae448791d4c9af9016bc9d5e9de166f0e">executeFeedback</a> (void)</td></tr>
<tr class="memdesc:ae448791d4c9af9016bc9d5e9de166f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the generated policy on the system. <br/></td></tr>
<tr class="separator:ae448791d4c9af9016bc9d5e9de166f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcd92332a3e7658e6f81f86b0883ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#afbcd92332a3e7658e6f81f86b0883ed0">executeFeedbackWithKidnapping</a> (void)</td></tr>
<tr class="memdesc:afbcd92332a3e7658e6f81f86b0883ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the generated policy on the system with kidnapping in the middle of a run.  <a href="#afbcd92332a3e7658e6f81f86b0883ed0">More...</a><br/></td></tr>
<tr class="separator:afbcd92332a3e7658e6f81f86b0883ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8267860838552b5b433212f142270615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8267860838552b5b433212f142270615">executeFeedbackWithRollout</a> (void)</td></tr>
<tr class="memdesc:a8267860838552b5b433212f142270615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the rollout policy algorithm (See ICRA '14 paper)  <a href="#a8267860838552b5b433212f142270615">More...</a><br/></td></tr>
<tr class="separator:a8267860838552b5b433212f142270615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1853095fafc72bba76846d94e8e4eba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1853095fafc72bba76846d94e8e4eba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af1853095fafc72bba76846d94e8e4eba">setMinFIRMNodes</a> (const unsigned int numNodes)</td></tr>
<tr class="memdesc:af1853095fafc72bba76846d94e8e4eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum number of <a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a> nodes. <br/></td></tr>
<tr class="separator:af1853095fafc72bba76846d94e8e4eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24323d0714ee325851ed0cc74b72c99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa24323d0714ee325851ed0cc74b72c99"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aa24323d0714ee325851ed0cc74b72c99">savePlannerData</a> ()</td></tr>
<tr class="memdesc:aa24323d0714ee325851ed0cc74b72c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the roadmap to an XML. <br/></td></tr>
<tr class="separator:aa24323d0714ee325851ed0cc74b72c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2283d09089ba48155430d9018c00a884"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2283d09089ba48155430d9018c00a884"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2283d09089ba48155430d9018c00a884">loadRoadMapFromFile</a> (const std::string pathToFile)</td></tr>
<tr class="memdesc:a2283d09089ba48155430d9018c00a884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the roadmap info from a file. <br/></td></tr>
<tr class="separator:a2283d09089ba48155430d9018c00a884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f1f2e8d35ae53c3356bb93abc6c29b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0f1f2e8d35ae53c3356bb93abc6c29b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setKidnappedState</b> (ompl::base::State *state)</td></tr>
<tr class="separator:ad0f1f2e8d35ae53c3356bb93abc6c29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b14b8cba99654cfa0a008b35f5e93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac77b14b8cba99654cfa0a008b35f5e93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac77b14b8cba99654cfa0a008b35f5e93">setPolicyExecutionSpace</a> (firm::SpaceInformation::SpaceInformationPtr executionSI)</td></tr>
<tr class="memdesc:ac77b14b8cba99654cfa0a008b35f5e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the policy execution space. <br/></td></tr>
<tr class="separator:ac77b14b8cba99654cfa0a008b35f5e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af6951ffec04529fd8da990978d7d8d19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6951ffec04529fd8da990978d7d8d19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af6951ffec04529fd8da990978d7d8d19">freeMemory</a> (void)</td></tr>
<tr class="memdesc:af6951ffec04529fd8da990978d7d8d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all the memory allocated by the planner. <br/></td></tr>
<tr class="separator:af6951ffec04529fd8da990978d7d8d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0caadb90c1695e05eade25e7211d88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e0caadb90c1695e05eade25e7211d88"></a>
virtual Vertex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a9e0caadb90c1695e05eade25e7211d88">addStateToGraph</a> (ompl::base::State *state, bool addReverseEdge=true, bool shouldCreateNodeController=true)</td></tr>
<tr class="memdesc:a9e0caadb90c1695e05eade25e7211d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a graph node for a given state (<em>state</em>), store it in the nearest neighbors data structure and then connect it to the roadmap in accordance to the connection strategy. <br/></td></tr>
<tr class="separator:a9e0caadb90c1695e05eade25e7211d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34535f25e4f3fb645fb65d57e3faf01b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a34535f25e4f3fb645fb65d57e3faf01b">uniteComponents</a> (Vertex m1, Vertex m2)</td></tr>
<tr class="memdesc:a34535f25e4f3fb645fb65d57e3faf01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a state from XML and add to Graph.  <a href="#a34535f25e4f3fb645fb65d57e3faf01b">More...</a><br/></td></tr>
<tr class="separator:a34535f25e4f3fb645fb65d57e3faf01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2045f113f0755ae8eeac2c35c7c08d41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2045f113f0755ae8eeac2c35c7c08d41"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2045f113f0755ae8eeac2c35c7c08d41">sameComponent</a> (Vertex m1, Vertex m2)</td></tr>
<tr class="memdesc:a2045f113f0755ae8eeac2c35c7c08d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two milestones (<em>m1</em> and <em>m2</em>) are part of the same connected component. This is not a const function since we use incremental connected components from boost. <br/></td></tr>
<tr class="separator:a2045f113f0755ae8eeac2c35c7c08d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33b03b6c78466e4a47f7b6d9f59d7f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae33b03b6c78466e4a47f7b6d9f59d7f8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae33b03b6c78466e4a47f7b6d9f59d7f8">growRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, ompl::base::State *workState)</td></tr>
<tr class="memdesc:ae33b03b6c78466e4a47f7b6d9f59d7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly sample the state space, add and connect nodes in the roadmap. Stop this process when the termination condition. <br/></td></tr>
<tr class="separator:ae33b03b6c78466e4a47f7b6d9f59d7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c4511064a0cd59f5b5ad756879c4ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0c4511064a0cd59f5b5ad756879c4ef"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ab0c4511064a0cd59f5b5ad756879c4ef">expandRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, std::vector&lt; ompl::base::State * &gt; &amp;workStates)</td></tr>
<tr class="memdesc:ab0c4511064a0cd59f5b5ad756879c4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bounding motions (the PRM expansion step) <br/></td></tr>
<tr class="separator:ab0c4511064a0cd59f5b5ad756879c4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c909fc53ceeeecb6992ccebf0ab60d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c909fc53ceeeecb6992ccebf0ab60d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a4c909fc53ceeeecb6992ccebf0ab60d6">checkForSolution</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, ompl::base::PathPtr &amp;solution)</td></tr>
<tr class="memdesc:a4c909fc53ceeeecb6992ccebf0ab60d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread that checks for solution. <br/></td></tr>
<tr class="separator:a4c909fc53ceeeecb6992ccebf0ab60d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937a58c35d6f8d5c26d09acbcc340d9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a937a58c35d6f8d5c26d09acbcc340d9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a937a58c35d6f8d5c26d09acbcc340d9a">existsPolicy</a> (const std::vector&lt; Vertex &gt; &amp;starts, const std::vector&lt; Vertex &gt; &amp;goals, ompl::base::PathPtr &amp;solution)</td></tr>
<tr class="memdesc:a937a58c35d6f8d5c26d09acbcc340d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there exists a policy, i.e., The given pair of <em>start</em> and <em>goal</em>, are in the same connected component. If a feedback policy is found, it is saved. <br/></td></tr>
<tr class="separator:a937a58c35d6f8d5c26d09acbcc340d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341a81deb4e550fbacf6c239a801d2a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a341a81deb4e550fbacf6c239a801d2a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a341a81deb4e550fbacf6c239a801d2a8">addedNewSolution</a> (void) const </td></tr>
<tr class="memdesc:a341a81deb4e550fbacf6c239a801d2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the addedSolution_ member. <br/></td></tr>
<tr class="separator:a341a81deb4e550fbacf6c239a801d2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ff922dfb8df66dbb82a6b6078959a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28ff922dfb8df66dbb82a6b6078959a0"></a>
virtual ompl::base::PathPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a28ff922dfb8df66dbb82a6b6078959a0">constructFeedbackPath</a> (const Vertex &amp;start, const Vertex &amp;goal)</td></tr>
<tr class="memdesc:a28ff922dfb8df66dbb82a6b6078959a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a feedback. <br/></td></tr>
<tr class="separator:a28ff922dfb8df66dbb82a6b6078959a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856ce7976a3b93c99da2e7bb98a076a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a856ce7976a3b93c99da2e7bb98a076a3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a856ce7976a3b93c99da2e7bb98a076a3">addEdgeToGraph</a> (const FIRM::Vertex a, const FIRM::Vertex b, bool &amp;edgeAdded)</td></tr>
<tr class="memdesc:a856ce7976a3b93c99da2e7bb98a076a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge from vertex a to b in graph. <br/></td></tr>
<tr class="separator:a856ce7976a3b93c99da2e7bb98a076a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ba6cde636a62e720afaf41bf0ebbf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2ba6cde636a62e720afaf41bf0ebbf6"></a>
virtual <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad2ba6cde636a62e720afaf41bf0ebbf6">generateEdgeControllerWithCost</a> (const Vertex a, const Vertex b, <a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">EdgeControllerType</a> &amp;edgeController)</td></tr>
<tr class="memdesc:ad2ba6cde636a62e720afaf41bf0ebbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the cost of the edge. <br/></td></tr>
<tr class="separator:ad2ba6cde636a62e720afaf41bf0ebbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfccb43f41872b8da9a4609c1748d21f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#abfccb43f41872b8da9a4609c1748d21f">generateEdgeController</a> (const ompl::base::State *start, const ompl::base::State *target, <a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">EdgeControllerType</a> &amp;edgeController)</td></tr>
<tr class="memdesc:abfccb43f41872b8da9a4609c1748d21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an edge controller and loads the edge properties from XML.  <a href="#abfccb43f41872b8da9a4609c1748d21f">More...</a><br/></td></tr>
<tr class="separator:abfccb43f41872b8da9a4609c1748d21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9061a8baf28a8a7192705a655394e68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9061a8baf28a8a7192705a655394e68"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af9061a8baf28a8a7192705a655394e68">generateNodeController</a> (ompl::base::State *state, <a class="el" href="class_controller.html">NodeControllerType</a> &amp;nodeController)</td></tr>
<tr class="memdesc:af9061a8baf28a8a7192705a655394e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the node controller that stabilizes the robot to the node and sets the stationary covariance at the node. <br/></td></tr>
<tr class="separator:af9061a8baf28a8a7192705a655394e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffdc57247b8f40899646195750b6a20"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a7ffdc57247b8f40899646195750b6a20">solveDynamicProgram</a> (const Vertex goalVertex)</td></tr>
<tr class="memdesc:a7ffdc57247b8f40899646195750b6a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the dynamic program to return a feedback policy.  <a href="#a7ffdc57247b8f40899646195750b6a20">More...</a><br/></td></tr>
<tr class="separator:a7ffdc57247b8f40899646195750b6a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80c1d4a2fc961fcdfb8939eb99a8b64"><td class="memItemLeft" align="right" valign="top">virtual Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac80c1d4a2fc961fcdfb8939eb99a8b64">generateRolloutPolicy</a> (const Vertex currentVertex)</td></tr>
<tr class="memdesc:ac80c1d4a2fc961fcdfb8939eb99a8b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the rollout policy.  <a href="#ac80c1d4a2fc961fcdfb8939eb99a8b64">More...</a><br/></td></tr>
<tr class="separator:ac80c1d4a2fc961fcdfb8939eb99a8b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4003d4144f6c32e9eaba79f292ec9ce4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4003d4144f6c32e9eaba79f292ec9ce4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addStateToVisualization</b> (ompl::base::State *state)</td></tr>
<tr class="separator:a4003d4144f6c32e9eaba79f292ec9ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9e316c11b1e2ff52b5ff65996d3a01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d9e316c11b1e2ff52b5ff65996d3a01"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sendFeedbackEdgesToViz</b> ()</td></tr>
<tr class="separator:a8d9e316c11b1e2ff52b5ff65996d3a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c28acaa03461e00d36327be6dae1479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c28acaa03461e00d36327be6dae1479"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a4c28acaa03461e00d36327be6dae1479">simulateKidnapping</a> ()</td></tr>
<tr class="memdesc:a4c28acaa03461e00d36327be6dae1479"><td class="mdescLeft">&#160;</td><td class="mdescRight">simulates a kidnapping, where the robot is disturbed to a random new location <br/></td></tr>
<tr class="separator:a4c28acaa03461e00d36327be6dae1479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028d35907dff71115003d1c74638b290"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a028d35907dff71115003d1c74638b290"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a028d35907dff71115003d1c74638b290">detectKidnapping</a> (ompl::base::State *previousState, ompl::base::State *newState)</td></tr>
<tr class="memdesc:a028d35907dff71115003d1c74638b290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects whether the robot was kidnapped or not. <br/></td></tr>
<tr class="separator:a028d35907dff71115003d1c74638b290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c8c2d00857070a6e0fcd4b0c3d293"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec9c8c2d00857070a6e0fcd4b0c3d293"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aec9c8c2d00857070a6e0fcd4b0c3d293">recoverLostRobot</a> (ompl::base::State *recoveredState)</td></tr>
<tr class="memdesc:aec9c8c2d00857070a6e0fcd4b0c3d293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when robot is lost, uses multi-modal planner to recover true position of robot. <br/></td></tr>
<tr class="separator:aec9c8c2d00857070a6e0fcd4b0c3d293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437305b9ca1e8e4592c239673075f6eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a437305b9ca1e8e4592c239673075f6eb"></a>
std::pair&lt; typename FIRM::Edge, <br class="typebreak"/>
double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a437305b9ca1e8e4592c239673075f6eb">getUpdatedNodeCostToGo</a> (const Vertex node)</td></tr>
<tr class="memdesc:a437305b9ca1e8e4592c239673075f6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the new cost to go from a node. <br/></td></tr>
<tr class="separator:a437305b9ca1e8e4592c239673075f6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0967139a72d4d7a9190a50aefb3bb593"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0967139a72d4d7a9190a50aefb3bb593"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a0967139a72d4d7a9190a50aefb3bb593">sendMostLikelyPathToViz</a> (const Vertex start, const Vertex goal)</td></tr>
<tr class="memdesc:a0967139a72d4d7a9190a50aefb3bb593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the most likely path to visualizer based on start location. <br/></td></tr>
<tr class="separator:a0967139a72d4d7a9190a50aefb3bb593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0713b86a8a2872e86dca3a496f3ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f0713b86a8a2872e86dca3a496f3ba1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>makeDataLogPath</b> ()</td></tr>
<tr class="separator:a7f0713b86a8a2872e86dca3a496f3ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c5cd9e0c7618758e1bd9ff0a7e604c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66c5cd9e0c7618758e1bd9ff0a7e604c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a66c5cd9e0c7618758e1bd9ff0a7e604c">writeTimeSeriesDataToFile</a> (std::string fname, std::string dataName)</td></tr>
<tr class="memdesc:a66c5cd9e0c7618758e1bd9ff0a7e604c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a time series data to a file. <br/></td></tr>
<tr class="separator:a66c5cd9e0c7618758e1bd9ff0a7e604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1381ddffa42b0bf2d36dc9c6d9d1da9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1381ddffa42b0bf2d36dc9c6d9d1da9d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a1381ddffa42b0bf2d36dc9c6d9d1da9d">starStrategy_</a></td></tr>
<tr class="memdesc:a1381ddffa42b0bf2d36dc9c6d9d1da9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the default connection strategy is the Star strategy. <br/></td></tr>
<tr class="separator:a1381ddffa42b0bf2d36dc9c6d9d1da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4307c058abb03b3a84c5c60e849c191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4307c058abb03b3a84c5c60e849c191"></a>
ompl::base::ValidStateSamplerPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af4307c058abb03b3a84c5c60e849c191">sampler_</a></td></tr>
<tr class="memdesc:af4307c058abb03b3a84c5c60e849c191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampler user for generating valid samples in the state space. <br/></td></tr>
<tr class="separator:af4307c058abb03b3a84c5c60e849c191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71a0e86b8a99f9eaa687f161d8d68e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af71a0e86b8a99f9eaa687f161d8d68e1"></a>
ompl::base::StateSamplerPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af71a0e86b8a99f9eaa687f161d8d68e1">simpleSampler_</a></td></tr>
<tr class="memdesc:af71a0e86b8a99f9eaa687f161d8d68e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampler user for generating random in the state space. <br/></td></tr>
<tr class="separator:af71a0e86b8a99f9eaa687f161d8d68e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed6858c0216ed9fc49f02e4aafc4443"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed6858c0216ed9fc49f02e4aafc4443"></a>
RoadmapNeighbors&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aeed6858c0216ed9fc49f02e4aafc4443">nn_</a></td></tr>
<tr class="memdesc:aeed6858c0216ed9fc49f02e4aafc4443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbors data structure. <br/></td></tr>
<tr class="separator:aeed6858c0216ed9fc49f02e4aafc4443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac954812b235fc64b57ea319bec7c80bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac954812b235fc64b57ea319bec7c80bb"></a>
<a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac954812b235fc64b57ea319bec7c80bb">g_</a></td></tr>
<tr class="memdesc:ac954812b235fc64b57ea319bec7c80bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connectivity graph. <br/></td></tr>
<tr class="separator:ac954812b235fc64b57ea319bec7c80bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333c7dec34b4c0977f85424b9fc3dc21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a333c7dec34b4c0977f85424b9fc3dc21"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a333c7dec34b4c0977f85424b9fc3dc21">startM_</a></td></tr>
<tr class="memdesc:a333c7dec34b4c0977f85424b9fc3dc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of start milestones. <br/></td></tr>
<tr class="separator:a333c7dec34b4c0977f85424b9fc3dc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb59b6121e120e14f30c58e567ec6a4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb59b6121e120e14f30c58e567ec6a4c"></a>
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aeb59b6121e120e14f30c58e567ec6a4c">goalM_</a></td></tr>
<tr class="memdesc:aeb59b6121e120e14f30c58e567ec6a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of goal milestones. <br/></td></tr>
<tr class="separator:aeb59b6121e120e14f30c58e567ec6a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f27981600a6b5ee4c5124b8f9bc640b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f27981600a6b5ee4c5124b8f9bc640b"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
<a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8f27981600a6b5ee4c5124b8f9bc640b">stateProperty_</a></td></tr>
<tr class="memdesc:a8f27981600a6b5ee4c5124b8f9bc640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the internal ompl::base::state at each Vertex. <br/></td></tr>
<tr class="separator:a8f27981600a6b5ee4c5124b8f9bc640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5651af4be68cf84115fbf6fe4b2c958d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5651af4be68cf84115fbf6fe4b2c958d"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
<a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a5651af4be68cf84115fbf6fe4b2c958d">totalConnectionAttemptsProperty_</a></td></tr>
<tr class="memdesc:a5651af4be68cf84115fbf6fe4b2c958d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the number of total connection attempts for a vertex. <br/></td></tr>
<tr class="separator:a5651af4be68cf84115fbf6fe4b2c958d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d31e5b2a0bf5921fb1c8f43e55338b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9d31e5b2a0bf5921fb1c8f43e55338b"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
<a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad9d31e5b2a0bf5921fb1c8f43e55338b">successfulConnectionAttemptsProperty_</a></td></tr>
<tr class="memdesc:ad9d31e5b2a0bf5921fb1c8f43e55338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the number of successful connection attempts for a vertex. <br/></td></tr>
<tr class="separator:ad9d31e5b2a0bf5921fb1c8f43e55338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe2eb302b9af9ced9bc26f03d369297"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebe2eb302b9af9ced9bc26f03d369297"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
boost::edge_weight_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aebe2eb302b9af9ced9bc26f03d369297">weightProperty_</a></td></tr>
<tr class="memdesc:aebe2eb302b9af9ced9bc26f03d369297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the weights of each Edge. <br/></td></tr>
<tr class="separator:aebe2eb302b9af9ced9bc26f03d369297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eba4eb39bce397127a9d41cf0b5cd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81eba4eb39bce397127a9d41cf0b5cd2"></a>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
boost::edge_index_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a81eba4eb39bce397127a9d41cf0b5cd2">edgeIDProperty_</a></td></tr>
<tr class="memdesc:a81eba4eb39bce397127a9d41cf0b5cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the indices of each Edge. <br/></td></tr>
<tr class="separator:a81eba4eb39bce397127a9d41cf0b5cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe52d3e291fc164ff9338765534e7ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe52d3e291fc164ff9338765534e7ce"></a>
boost::disjoint_sets<br class="typebreak"/>
&lt; boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
boost::vertex_rank_t &gt;::type, <br class="typebreak"/>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
boost::vertex_predecessor_t &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#adbe52d3e291fc164ff9338765534e7ce">disjointSets_</a></td></tr>
<tr class="memdesc:adbe52d3e291fc164ff9338765534e7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that maintains the connected components. <br/></td></tr>
<tr class="separator:adbe52d3e291fc164ff9338765534e7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517174c1ae349153df76f81f2ba2b2f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a517174c1ae349153df76f81f2ba2b2f1"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a517174c1ae349153df76f81f2ba2b2f1">maxEdgeID_</a></td></tr>
<tr class="memdesc:a517174c1ae349153df76f81f2ba2b2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum unique id number used so for for edges. <br/></td></tr>
<tr class="separator:a517174c1ae349153df76f81f2ba2b2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcb0aef9c9101c4569f5b6bb5f576ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fcb0aef9c9101c4569f5b6bb5f576ae"></a>
<a class="el" href="class_f_i_r_m.html#a14c6f3351c41a0416524ab2e01388e03">ConnectionStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a0fcb0aef9c9101c4569f5b6bb5f576ae">connectionStrategy_</a></td></tr>
<tr class="memdesc:a0fcb0aef9c9101c4569f5b6bb5f576ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the milestones to attempt connections with. <br/></td></tr>
<tr class="separator:a0fcb0aef9c9101c4569f5b6bb5f576ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cc77417338d946478f5a71e6bd5b70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42cc77417338d946478f5a71e6bd5b70"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a42cc77417338d946478f5a71e6bd5b70">userSetConnectionStrategy_</a></td></tr>
<tr class="memdesc:a42cc77417338d946478f5a71e6bd5b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the employed connection strategy was set by the user (or defaults are assumed) <br/></td></tr>
<tr class="separator:a42cc77417338d946478f5a71e6bd5b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e91a5d8aba0ccaca892fb9eeda4ef41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e91a5d8aba0ccaca892fb9eeda4ef41"></a>
ompl::RNG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2e91a5d8aba0ccaca892fb9eeda4ef41">rng_</a></td></tr>
<tr class="memdesc:a2e91a5d8aba0ccaca892fb9eeda4ef41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator. <br/></td></tr>
<tr class="separator:a2e91a5d8aba0ccaca892fb9eeda4ef41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc413ddef9b66cd337c0e19c6ba79d84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc413ddef9b66cd337c0e19c6ba79d84"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#afc413ddef9b66cd337c0e19c6ba79d84">addedSolution_</a></td></tr>
<tr class="memdesc:afc413ddef9b66cd337c0e19c6ba79d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating that a solution has been added during <a class="el" href="class_f_i_r_m.html#a02f3c98de4840594193ba5bf7ff3ca63" title="The key function that solves the planning problem. ">solve()</a> <br/></td></tr>
<tr class="separator:afc413ddef9b66cd337c0e19c6ba79d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71c316b447bb7b404dc27c8d673fd55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae71c316b447bb7b404dc27c8d673fd55"></a>
boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae71c316b447bb7b404dc27c8d673fd55">graphMutex_</a></td></tr>
<tr class="memdesc:ae71c316b447bb7b404dc27c8d673fd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to guard access to the Graph member (g_) <br/></td></tr>
<tr class="separator:ae71c316b447bb7b404dc27c8d673fd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4f91dc510bf7b5b68b4da5cfd90718"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd4f91dc510bf7b5b68b4da5cfd90718"></a>
const <br class="typebreak"/>
firm::SpaceInformation::SpaceInformationPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#afd4f91dc510bf7b5b68b4da5cfd90718">siF_</a></td></tr>
<tr class="memdesc:afd4f91dc510bf7b5b68b4da5cfd90718"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base::SpaceInformation cast as <a class="el" href="classfirm_1_1_space_information.html">firm::SpaceInformation</a>, for convenience. <br/></td></tr>
<tr class="separator:afd4f91dc510bf7b5b68b4da5cfd90718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c508cb1c9346d2d5bc253e1621b798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37c508cb1c9346d2d5bc253e1621b798"></a>
firm::SpaceInformation::SpaceInformationPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a37c508cb1c9346d2d5bc253e1621b798">policyExecutionSI_</a></td></tr>
<tr class="memdesc:a37c508cb1c9346d2d5bc253e1621b798"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the space in which the policy is executed. By default it is set to the same space that is passed to the constructer. If this space is changed, the observations and controls are both in the context of this new space. Use the setPolicyExecutionSpace function to change this parameter. Particularly useful if you wish to drive a real robot and get sensor readings. <br/></td></tr>
<tr class="separator:a37c508cb1c9346d2d5bc253e1621b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfacc68b478054d0b99a3965d33d718a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfacc68b478054d0b99a3965d33d718a"></a>
std::map&lt; Edge, <br class="typebreak"/>
<a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">EdgeControllerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#abfacc68b478054d0b99a3965d33d718a">edgeControllers_</a></td></tr>
<tr class="memdesc:abfacc68b478054d0b99a3965d33d718a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the edge controllers according to the edges. <br/></td></tr>
<tr class="separator:abfacc68b478054d0b99a3965d33d718a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80211b920fb34ee04779c9af2c0d1c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac80211b920fb34ee04779c9af2c0d1c4"></a>
std::map&lt; Vertex, <br class="typebreak"/>
<a class="el" href="class_controller.html">NodeControllerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac80211b920fb34ee04779c9af2c0d1c4">nodeControllers_</a></td></tr>
<tr class="memdesc:ac80211b920fb34ee04779c9af2c0d1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the node controllers according to the node (vertex) ids. <br/></td></tr>
<tr class="separator:ac80211b920fb34ee04779c9af2c0d1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da49edf6ea58f4116cd3c31022bd693"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2da49edf6ea58f4116cd3c31022bd693"></a>
std::map&lt; Vertex, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>costToGo_</b></td></tr>
<tr class="separator:a2da49edf6ea58f4116cd3c31022bd693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9e2e83177ef121adc36ef7f9e5d16d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae9e2e83177ef121adc36ef7f9e5d16d"></a>
std::map&lt; Vertex, Edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>feedback_</b></td></tr>
<tr class="separator:aae9e2e83177ef121adc36ef7f9e5d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cff52eb2c31715ab8341b9daea1a3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17cff52eb2c31715ab8341b9daea1a3f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a17cff52eb2c31715ab8341b9daea1a3f">numParticles_</a></td></tr>
<tr class="memdesc:a17cff52eb2c31715ab8341b9daea1a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of particles to use for monte carlo simulations. <br/></td></tr>
<tr class="separator:a17cff52eb2c31715ab8341b9daea1a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9de6c5accdea0f9b6d1ff458350036"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add9de6c5accdea0f9b6d1ff458350036"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#add9de6c5accdea0f9b6d1ff458350036">minFIRMNodes_</a></td></tr>
<tr class="memdesc:add9de6c5accdea0f9b6d1ff458350036"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum number of nodes that should be sampled. <br/></td></tr>
<tr class="separator:add9de6c5accdea0f9b6d1ff458350036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcb67a67bdcc9b4a625df981345c3b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbcb67a67bdcc9b4a625df981345c3b2"></a>
<a class="el" href="class_n_b_m3_p.html">NBM3P</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>policyGenerator_</b></td></tr>
<tr class="separator:afbcb67a67bdcc9b4a625df981345c3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba7b75c6e4a881c8639f6dc836b154c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeba7b75c6e4a881c8639f6dc836b154c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>loadedRoadmapFromFile_</b></td></tr>
<tr class="separator:aeba7b75c6e4a881c8639f6dc836b154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64580032f7517034b53e49502685196d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64580032f7517034b53e49502685196d"></a>
std::vector&lt; std::pair<br class="typebreak"/>
&lt; std::pair&lt; int, int &gt;<br class="typebreak"/>
, <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>loadedEdgeProperties_</b></td></tr>
<tr class="separator:a64580032f7517034b53e49502685196d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a2d7b0eafa2589b9cfae28e478d77d51a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d7b0eafa2589b9cfae28e478d77d51a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2d7b0eafa2589b9cfae28e478d77d51a">isStartVertex</a> (const Vertex v)</td></tr>
<tr class="memdesc:a2d7b0eafa2589b9cfae28e478d77d51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this vertex belongs to the list of start vertices. <br/></td></tr>
<tr class="separator:a2d7b0eafa2589b9cfae28e478d77d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09d6e5ce04752ac6b16e1e59145cbed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab09d6e5ce04752ac6b16e1e59145cbed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ab09d6e5ce04752ac6b16e1e59145cbed">isGoalVertex</a> (const Vertex v)</td></tr>
<tr class="memdesc:ab09d6e5ce04752ac6b16e1e59145cbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this vertex belongs to the list of goal vertices. <br/></td></tr>
<tr class="separator:ab09d6e5ce04752ac6b16e1e59145cbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3847c3baf1f549bb9270163e7a6365eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3847c3baf1f549bb9270163e7a6365eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a3847c3baf1f549bb9270163e7a6365eb">showRolloutConnections</a> (const Vertex v)</td></tr>
<tr class="memdesc:a3847c3baf1f549bb9270163e7a6365eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rollout connections to visualization. <br/></td></tr>
<tr class="separator:a3847c3baf1f549bb9270163e7a6365eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e63922880cb24e7feeb52c494a7b194"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e63922880cb24e7feeb52c494a7b194"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a0e63922880cb24e7feeb52c494a7b194">evaluateSuccessProbability</a> (const Edge currentEdge, const Vertex start, const Vertex goal)</td></tr>
<tr class="memdesc:a0e63922880cb24e7feeb52c494a7b194"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the current success probability by multiplying the success probability of current edge and all future edges to goal vertex <br/></td></tr>
<tr class="separator:a0e63922880cb24e7feeb52c494a7b194"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a6d99f5f4a17a52269b8d36e906cebadb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d99f5f4a17a52269b8d36e906cebadb"></a>
ompl::base::State *&#160;</td><td class="memItemRight" valign="bottom"><b>kidnappedState_</b></td></tr>
<tr class="separator:a6d99f5f4a17a52269b8d36e906cebadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105815fd042e10dfb3952c3f83f6758a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a105815fd042e10dfb3952c3f83f6758a"></a>
std::vector&lt; std::pair&lt; int, <br class="typebreak"/>
float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>costToGoHistory_</b></td></tr>
<tr class="separator:a105815fd042e10dfb3952c3f83f6758a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b1115c3ab7a0e4069be33b9c990592"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5b1115c3ab7a0e4069be33b9c990592"></a>
std::vector&lt; std::pair&lt; int, <br class="typebreak"/>
double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>successProbabilityHistory_</b></td></tr>
<tr class="separator:ae5b1115c3ab7a0e4069be33b9c990592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157e610a2e7ebd1462f759b95807bcfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a157e610a2e7ebd1462f759b95807bcfa"></a>
std::vector&lt; std::pair&lt; int, <br class="typebreak"/>
std::vector&lt; float &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>weightsHistory_</b></td></tr>
<tr class="separator:a157e610a2e7ebd1462f759b95807bcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20d0c5df78982bdbf600cf79be3fcb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae20d0c5df78982bdbf600cf79be3fcb5"></a>
std::vector&lt; std::pair&lt; int, <br class="typebreak"/>
int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodeReachedHistory_</b></td></tr>
<tr class="separator:ae20d0c5df78982bdbf600cf79be3fcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c0b7103ec15443c8b29fcadac96e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e3c0b7103ec15443c8b29fcadac96e3"></a>
std::vector&lt; std::pair&lt; int, <br class="typebreak"/>
double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>velocityHistory_</b></td></tr>
<tr class="separator:a6e3c0b7103ec15443c8b29fcadac96e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa017748148fb7c1825db2b3e57e91c45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa017748148fb7c1825db2b3e57e91c45"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>currentTimeStep_</b></td></tr>
<tr class="separator:aa017748148fb7c1825db2b3e57e91c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac337657961cddb797ba25f2f8d4caec7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac337657961cddb797ba25f2f8d4caec7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberofNodesReached_</b></td></tr>
<tr class="separator:ac337657961cddb797ba25f2f8d4caec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9f93a4a345101aca1075401232614e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac9f93a4a345101aca1075401232614e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>executionCost_</b></td></tr>
<tr class="separator:aac9f93a4a345101aca1075401232614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963519ae960aa0f5979c19055b488004"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a963519ae960aa0f5979c19055b488004"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>logFilePath_</b></td></tr>
<tr class="separator:a963519ae960aa0f5979c19055b488004"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Feedback Information RoadMap planner. </p>
<p><a class="anchor" id="FIRM"></a></p>
<dl class="section user"><dt>Short description</dt><dd>Feedback Information RoadMap (<a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a>), is a multi-query approach for planning under uncertainty which is a belief-space variant of probabilistic roadmap methods. The crucial feature of <a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a> is that the costs associated with the edges are independent of each other, and in this sense it is the first method that generates a graph in belief space that preserves the optimal substructure property. From a practical point of view, <a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a> is a robust and reliable planning framework. It is robust since the solution is a feedback and there is no need for expensive replanning. It is reliable because accurate collision probabilities can be computed along the edges. In addition, <a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a> is a scalable framework, where the complexity of planning with <a class="el" href="class_f_i_r_m.html" title="Feedback Information RoadMap planner. ">FIRM</a> is a constant multiplier of the complexity of planning with PRM.</dd></dl>
<dl class="section user"><dt>External documentation</dt><dd><ol type="1">
<li>A. Agha-mohammadi, Suman Chakravorty, Nancy Amato, "FIRM: Sampling-based Feedback Motion Planning Under Motion
Uncertainty and Imperfect Measurements", International Journal of Robotics Research, 33(2):268-304, February 2014</li>
<li>A. Agha-mohammadi, Saurav Agarwal, Aditya Mahadevan, Suman Chakravorty, Daniel Tomkins, Jory Denny, Nancy Amato, "Robust Online Belief Space
Planning in Changing Environments: Application to Physical Mobile Robots," In Proc. IEEE Int. Conf. Robot. Autom. (ICRA), Hong Kong, China, May 2014.</li>
</ol>
</dd></dl>
<p><a href="http://www.mit.edu/~aliagha/Web/pubpdfs/2014.Ali.Suman.ea.IJRR_FIRM.pdf">[PDF]</a> </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a70abcb24fbc9f836b94119f65c8f8a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_controller.html">Controller</a>&lt;<a class="el" href="class_r_h_c_i_create.html">RHCICreate</a>, <a class="el" href="class_extended_k_f.html">ExtendedKF</a>&gt; <a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">FIRM::EdgeControllerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defining the edge and node controller types </p>

</div>
</div>
<a class="anchor" id="a687e9f4243b22c30ee1fa5da22a85053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::bidirectionalS, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a>, ompl::base::State*, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a>, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a>, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a>, unsigned int, boost::property &lt; boost::vertex_predecessor_t, unsigned long int, boost::property &lt; boost::vertex_rank_t, unsigned long int &gt; &gt; &gt; &gt; &gt; &gt;, boost::property &lt; boost::edge_weight_t, <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a> , boost::property &lt; boost::edge_index_t, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a>, unsigned int &gt; &gt; &gt; &gt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">FIRM::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying roadmap graph. </p>
<dl class="section user"><dt>Edges are directed and have a weight property called FIRMWeight. This weight property</dt><dd>stores information about the edge controller identification, transition probability and execution cost. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afbcd92332a3e7658e6f81f86b0883ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::executeFeedbackWithKidnapping </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the generated policy on the system with kidnapping in the middle of a run. </p>
<ol type="1">
<li>Check if innovation i.e. change in trace(cov) between start and end state is high</li>
<li>If the change is high, then switch to lost mode</li>
<li>Sample modes and run policygen till you converge to one mode</li>
<li>get back to policy execution</li>
</ol>

</div>
</div>
<a class="anchor" id="a8267860838552b5b433212f142270615"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::executeFeedbackWithRollout </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the rollout policy algorithm (See ICRA '14 paper) </p>
<p>Instead of executing the entire controller, we need to execute N steps, then calculate the cost to go through the neighboring nodes. Whichever gives the lowest cost to go, is our new path. Do this at every N steps.</p>

</div>
</div>
<a class="anchor" id="abfccb43f41872b8da9a4609c1748d21f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::generateEdgeController </td>
          <td>(</td>
          <td class="paramtype">const ompl::base::State *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ompl::base::State *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">FIRM::EdgeControllerType</a> &amp;&#160;</td>
          <td class="paramname"><em>edgeController</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates an edge controller and loads the edge properties from XML. </p>
<p>Generates the edge controller that drives the robot from start to end of edge </p>

</div>
</div>
<a class="anchor" id="ac80c1d4a2fc961fcdfb8939eb99a8b64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FIRM::Edge FIRM::generateRolloutPolicy </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>currentVertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the rollout policy. </p>
<p>For the given node, find the out edges and see the total cost of taking that edge The cost of taking the edge is cost to go from the target of the edge + the cost of the edge itself</p>

</div>
</div>
<a class="anchor" id="a8017d1847e682f39c2cbce33e904af57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::setConnectionStrategy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_i_r_m.html#a14c6f3351c41a0416524ab2e01388e03">ConnectionStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>connectionStrategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the connection strategy function that specifies the milestones that connection attempts will be made to for a given milestone. </p>
<dl class="section user"><dt>The behavior and performance of PRM can be changed drastically</dt><dd>by varying the number and properties of the milestones that are connected to each other.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdef</td><td>A function that takes a milestone as an argument and returns a collection of other milestones to which a connection attempt must be made. The default connection strategy is to connect a milestone's 10 closest neighbors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ffdc57247b8f40899646195750b6a20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::solveDynamicProgram </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>goalVertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the dynamic program to return a feedback policy. </p>
<p>&ndash;NOTES&ndash; Assign a high cost to go initially for all nodes that are not in the goal connected component. For nodes that are in the goal cc, we assign goal cost to go for the goal and init cost to go for all other nodes.</p>

</div>
</div>
<a class="anchor" id="a34535f25e4f3fb645fb65d57e3faf01b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FIRM::uniteComponents </td>
          <td>(</td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vertex&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a state from XML and add to Graph. </p>
<p>Make two milestones (<em>m1</em> and <em>m2</em>) be part of the same connected component. The component with fewer elements will get the id of the component with more elements. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/Planner/<a class="el" href="_f_i_r_m_8h_source.html">FIRM.h</a></li>
<li>src/Planner/FIRM.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 4 2016 11:17:22 for EDPL-OMPL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
