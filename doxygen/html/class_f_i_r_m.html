<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FIRM-OMPL: FIRM Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">FIRM-OMPL
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">FIRM Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="FIRM" -->
<p>Feedback Information RoadMap planner.  
 <a href="class_f_i_r_m.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_f_i_r_m_8h_source.html">FIRM.h</a>&gt;</code></p>

<p><a href="class_f_i_r_m-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::adjacency_list<br class="typebreak"/>
&lt; boost::vecS, boost::vecS, <br class="typebreak"/>
boost::bidirectionalS, <br class="typebreak"/>
boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a>, <br class="typebreak"/>
ompl::base::State <br class="typebreak"/>
*, boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a>, <br class="typebreak"/>
unsigned int, boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a>, <br class="typebreak"/>
unsigned int, boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a>, unsigned int, <br class="typebreak"/>
boost::property<br class="typebreak"/>
&lt; boost::vertex_predecessor_t, <br class="typebreak"/>
unsigned long int, <br class="typebreak"/>
boost::property<br class="typebreak"/>
&lt; boost::vertex_rank_t, <br class="typebreak"/>
unsigned long int &gt;<br class="typebreak"/>
 &gt; &gt; &gt; &gt; &gt;, boost::property<br class="typebreak"/>
&lt; boost::edge_weight_t, <br class="typebreak"/>
<a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a>, boost::property<br class="typebreak"/>
&lt; boost::edge_index_t, <br class="typebreak"/>
unsigned int, boost::property<br class="typebreak"/>
&lt; <a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a>, unsigned int &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying roadmap graph.  <a href="#a687e9f4243b22c30ee1fa5da22a85053"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07eb05796ed64797c900b193aafa9031"></a><!-- doxytag: member="FIRM::Vertex" ref="a07eb05796ed64797c900b193aafa9031" args="" -->
typedef boost::graph_traits<br class="typebreak"/>
&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &gt;::vertex_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>Vertex</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88889998bf429572821d467eb44c67c6"></a><!-- doxytag: member="FIRM::Edge" ref="a88889998bf429572821d467eb44c67c6" args="" -->
typedef boost::graph_traits<br class="typebreak"/>
&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &gt;::edge_descriptor&#160;</td><td class="memItemRight" valign="bottom"><b>Edge</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a687705deb489cff3a2d40b7bec6bdc29"></a><!-- doxytag: member="FIRM::RoadmapNeighbors" ref="a687705deb489cff3a2d40b7bec6bdc29" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; ompl::NearestNeighbors<br class="typebreak"/>
&lt; Vertex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RoadmapNeighbors</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15cfbcaf52c0bdd5e6c1a969bbf7ea1e"></a><!-- doxytag: member="FIRM::ConnectionStrategy" ref="a15cfbcaf52c0bdd5e6c1a969bbf7ea1e" args="" -->
typedef boost::function<br class="typebreak"/>
&lt; std::vector&lt; Vertex &gt;<br class="typebreak"/>
 &amp;(const Vertex)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a15cfbcaf52c0bdd5e6c1a969bbf7ea1e">ConnectionStrategy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function returning the milestones that should be attempted to connect to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2482eee2e5248d5bff3b3b56e5a593b3"></a><!-- doxytag: member="FIRM::ConnectionFilter" ref="a2482eee2e5248d5bff3b3b56e5a593b3" args="" -->
typedef boost::function&lt; bool(const <br class="typebreak"/>
Vertex &amp;, const Vertex &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2482eee2e5248d5bff3b3b56e5a593b3">ConnectionFilter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that can reject connections. This is called after previous connections from the neighbor list have been added to the roadmap. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_controller.html">Controller</a>&lt; <a class="el" href="class_r_h_c_i_create.html">RHCICreate</a>, <br class="typebreak"/>
<a class="el" href="class_extended_k_f.html">ExtendedKF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">EdgeControllerType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf37596ffd4dbf633d7cd0f27347d15c"></a><!-- doxytag: member="FIRM::NodeControllerType" ref="adf37596ffd4dbf633d7cd0f27347d15c" args="" -->
typedef <a class="el" href="class_controller.html">Controller</a>&lt; <a class="el" href="class_r_h_c_i_create.html">RHCICreate</a>, <br class="typebreak"/>
<a class="el" href="class_linearized_k_f.html">LinearizedKF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeControllerType</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45dfdcb347763c633bf46ee653c35ce9"></a><!-- doxytag: member="FIRM::FIRM" ref="a45dfdcb347763c633bf46ee653c35ce9" args="(const firm::SpaceInformation::SpaceInformationPtr &amp;si, bool debugMode=false, bool starStrategy=false)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a45dfdcb347763c633bf46ee653c35ce9">FIRM</a> (const firm::SpaceInformation::SpaceInformationPtr &amp;si, bool debugMode=false, bool starStrategy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09a7ff97d8202a82ca7f6dddfd7ba185"></a><!-- doxytag: member="FIRM::setProblemDefinition" ref="a09a7ff97d8202a82ca7f6dddfd7ba185" args="(const ompl::base::ProblemDefinitionPtr &amp;pdef)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setProblemDefinition</b> (const ompl::base::ProblemDefinitionPtr &amp;pdef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8017d1847e682f39c2cbce33e904af57">setConnectionStrategy</a> (const <a class="el" href="class_f_i_r_m.html#a15cfbcaf52c0bdd5e6c1a969bbf7ea1e">ConnectionStrategy</a> &amp;connectionStrategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the connection strategy function that specifies the milestones that connection attempts will be made to for a given milestone.  <a href="#a8017d1847e682f39c2cbce33e904af57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a87b6c094c21b956a469a2b69cd387c"></a><!-- doxytag: member="FIRM::setMaxNearestNeighbors" ref="a2a87b6c094c21b956a469a2b69cd387c" args="(unsigned int k)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2a87b6c094c21b956a469a2b69cd387c">setMaxNearestNeighbors</a> (unsigned int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that sets the connection strategy to the default one with k nearest neighbors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a3f85ba51a7c3b62b75df7f7c16064cec">setConnectionFilter</a> (const <a class="el" href="class_f_i_r_m.html#a2482eee2e5248d5bff3b3b56e5a593b3">ConnectionFilter</a> &amp;connectionFilter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function that can reject a milestone connection.  <a href="#a3f85ba51a7c3b62b75df7f7c16064cec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f2e6a8c5dac3a0629f1dd0ac2313b9c"></a><!-- doxytag: member="FIRM::constructRoadmap" ref="a5f2e6a8c5dac3a0629f1dd0ac2313b9c" args="(const ompl::base::PlannerTerminationCondition &amp;ptc)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a5f2e6a8c5dac3a0629f1dd0ac2313b9c">constructRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">While the termination condition allows, this function will construct the roadmap (using <a class="el" href="class_f_i_r_m.html#a947186c6e6be0b513efe0e0b476fef88" title="If the user desires, the roadmap can be improved for the given time (seconds). The solve() method wil...">growRoadmap()</a> and <a class="el" href="class_f_i_r_m.html#ad9cd5472a8bd1b1fcb83763128f7fd75" title="Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansio...">expandRoadmap()</a>, maintaining a 2:1 ratio for growing/expansion of roadmap) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a947186c6e6be0b513efe0e0b476fef88"></a><!-- doxytag: member="FIRM::growRoadmap" ref="a947186c6e6be0b513efe0e0b476fef88" args="(double growTime)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a947186c6e6be0b513efe0e0b476fef88">growRoadmap</a> (double growTime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user desires, the roadmap can be improved for the given time (seconds). The solve() method will also improve the roadmap, as needed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8e741b0af39a64d34dcfa4f29c0e509"></a><!-- doxytag: member="FIRM::growRoadmap" ref="ae8e741b0af39a64d34dcfa4f29c0e509" args="(const ompl::base::PlannerTerminationCondition &amp;ptc)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae8e741b0af39a64d34dcfa4f29c0e509">growRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">If the user desires, the roadmap can be improved until a given condition is true. The solve() method will also improve the roadmap, as needed. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9cd5472a8bd1b1fcb83763128f7fd75"></a><!-- doxytag: member="FIRM::expandRoadmap" ref="ad9cd5472a8bd1b1fcb83763128f7fd75" args="(double expandTime)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad9cd5472a8bd1b1fcb83763128f7fd75">expandRoadmap</a> (double expandTime)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansion step) for the given time (seconds). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac520fbbb43b0e3100498aa29117f0b9"></a><!-- doxytag: member="FIRM::expandRoadmap" ref="aac520fbbb43b0e3100498aa29117f0b9" args="(const ompl::base::PlannerTerminationCondition &amp;ptc)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aac520fbbb43b0e3100498aa29117f0b9">expandRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bouncing motions (the PRM expansion step) until the given condition evaluates true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02f3c98de4840594193ba5bf7ff3ca63"></a><!-- doxytag: member="FIRM::solve" ref="a02f3c98de4840594193ba5bf7ff3ca63" args="(const ompl::base::PlannerTerminationCondition &amp;ptc)" -->
virtual ompl::base::PlannerStatus&#160;</td><td class="memItemRight" valign="bottom"><b>solve</b> (const ompl::base::PlannerTerminationCondition &amp;ptc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7c24814ea6b8cad9cad350dea66560"></a><!-- doxytag: member="FIRM::clearQuery" ref="acf7c24814ea6b8cad9cad350dea66560" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearQuery</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe5298e85713c7a736d6b8936f7171af"></a><!-- doxytag: member="FIRM::clear" ref="afe5298e85713c7a736d6b8936f7171af" args="(void)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> (void)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8dd7c5ed3fa065f5f37d79bc1d220474"></a><!-- doxytag: member="FIRM::setNearestNeighbors" ref="a8dd7c5ed3fa065f5f37d79bc1d220474" args="(void)" -->
template&lt;template&lt; typename T &gt; class NN&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8dd7c5ed3fa065f5f37d79bc1d220474">setNearestNeighbors</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a different nearest neighbors datastructure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c43a180deb28296e4cab5c6939c600"></a><!-- doxytag: member="FIRM::setup" ref="a78c43a180deb28296e4cab5c6939c600" args="(void)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacad0b0dfc1413f78c6dc76fdbac9ce7"></a><!-- doxytag: member="FIRM::getRoadmap" ref="aacad0b0dfc1413f78c6dc76fdbac9ce7" args="(void) const " -->
const <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getRoadmap</b> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a98fdb0da781d77fe6ff9a55e8a7a34"></a><!-- doxytag: member="FIRM::distanceFunction" ref="a9a98fdb0da781d77fe6ff9a55e8a7a34" args="(const Vertex a, const Vertex b) const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a9a98fdb0da781d77fe6ff9a55e8a7a34">distanceFunction</a> (const Vertex a, const Vertex b) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two milestones (this is simply distance between the states of the milestones) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a558fbb0135ab096d3cd06e65b88533de"></a><!-- doxytag: member="FIRM::milestoneCount" ref="a558fbb0135ab096d3cd06e65b88533de" args="(void) const " -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a558fbb0135ab096d3cd06e65b88533de">milestoneCount</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distance between two milestones (this is simply distance between the states of the milestones) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6df82888d88ab8479f92f9f3e453c2e"></a><!-- doxytag: member="FIRM::getNearestNeighbors" ref="ad6df82888d88ab8479f92f9f3e453c2e" args="(void)" -->
const RoadmapNeighbors &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getNearestNeighbors</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae448791d4c9af9016bc9d5e9de166f0e"></a><!-- doxytag: member="FIRM::executeFeedback" ref="ae448791d4c9af9016bc9d5e9de166f0e" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae448791d4c9af9016bc9d5e9de166f0e">executeFeedback</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the generated policy on the system. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6951ffec04529fd8da990978d7d8d19"></a><!-- doxytag: member="FIRM::freeMemory" ref="af6951ffec04529fd8da990978d7d8d19" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af6951ffec04529fd8da990978d7d8d19">freeMemory</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all the memory allocated by the planner. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b72ace6d1708b25bf8c7f69331ae82b"></a><!-- doxytag: member="FIRM::addMilestone" ref="a6b72ace6d1708b25bf8c7f69331ae82b" args="(ompl::base::State *state)" -->
virtual Vertex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a6b72ace6d1708b25bf8c7f69331ae82b">addMilestone</a> (ompl::base::State *state)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a milestone for a given state (<em>state</em>), store it in the nearest neighbors data structure and then connect it to the roadmap in accordance to the connection strategy. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34535f25e4f3fb645fb65d57e3faf01b"></a><!-- doxytag: member="FIRM::uniteComponents" ref="a34535f25e4f3fb645fb65d57e3faf01b" args="(Vertex m1, Vertex m2)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a34535f25e4f3fb645fb65d57e3faf01b">uniteComponents</a> (Vertex m1, Vertex m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Make two milestones (<em>m1</em> and <em>m2</em>) be part of the same connected component. The component with fewer elements will get the id of the component with more elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2045f113f0755ae8eeac2c35c7c08d41"></a><!-- doxytag: member="FIRM::sameComponent" ref="a2045f113f0755ae8eeac2c35c7c08d41" args="(Vertex m1, Vertex m2)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2045f113f0755ae8eeac2c35c7c08d41">sameComponent</a> (Vertex m1, Vertex m2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two milestones (<em>m1</em> and <em>m2</em>) are part of the same connected component. This is not a const function since we use incremental connected components from boost. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae33b03b6c78466e4a47f7b6d9f59d7f8"></a><!-- doxytag: member="FIRM::growRoadmap" ref="ae33b03b6c78466e4a47f7b6d9f59d7f8" args="(const ompl::base::PlannerTerminationCondition &amp;ptc, ompl::base::State *workState)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae33b03b6c78466e4a47f7b6d9f59d7f8">growRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, ompl::base::State *workState)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly sample the state space, add and connect milestones in the roadmap. Stop this process when the termination condition <em>ptc</em> returns true. Use <em>workState</em> as temporary memory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0c4511064a0cd59f5b5ad756879c4ef"></a><!-- doxytag: member="FIRM::expandRoadmap" ref="ab0c4511064a0cd59f5b5ad756879c4ef" args="(const ompl::base::PlannerTerminationCondition &amp;ptc, std::vector&lt; ompl::base::State * &gt; &amp;workStates)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ab0c4511064a0cd59f5b5ad756879c4ef">expandRoadmap</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, std::vector&lt; ompl::base::State * &gt; &amp;workStates)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to connect disjoint components in the roadmap using random bounding motions (the PRM expansion step) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a4c909fc53ceeeecb6992ccebf0ab60d6">checkForSolution</a> (const ompl::base::PlannerTerminationCondition &amp;ptc, ompl::base::PathPtr &amp;solution)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab237fb0d7978ef4156769fc7c1d77b2b"></a><!-- doxytag: member="FIRM::haveSolution" ref="ab237fb0d7978ef4156769fc7c1d77b2b" args="(const std::vector&lt; Vertex &gt; &amp;starts, const std::vector&lt; Vertex &gt; &amp;goals, ompl::base::PathPtr &amp;solution)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ab237fb0d7978ef4156769fc7c1d77b2b">haveSolution</a> (const std::vector&lt; Vertex &gt; &amp;starts, const std::vector&lt; Vertex &gt; &amp;goals, ompl::base::PathPtr &amp;solution)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there exists a solution, i.e., there exists a pair of milestones such that the first is in <em>start</em> and the second is in <em>goal</em>, and the two milestones are in the same connected component. If a solution is found, the path is saved. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a341a81deb4e550fbacf6c239a801d2a8"></a><!-- doxytag: member="FIRM::addedNewSolution" ref="a341a81deb4e550fbacf6c239a801d2a8" args="(void) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a341a81deb4e550fbacf6c239a801d2a8">addedNewSolution</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the addedSolution_ member. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ompl::base::PathPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a28ff922dfb8df66dbb82a6b6078959a0">constructFeedbackPath</a> (const Vertex &amp;start, const Vertex &amp;goal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two milestones from the same connected component, construct a path connecting them and set it as the solution.  <a href="#a28ff922dfb8df66dbb82a6b6078959a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9774dc171985f4521c02b5db8552397f"></a><!-- doxytag: member="FIRM::addEdgeToGraph" ref="a9774dc171985f4521c02b5db8552397f" args="(const Vertex a, const Vertex b)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a9774dc171985f4521c02b5db8552397f">addEdgeToGraph</a> (const Vertex a, const Vertex b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge from vertex a to b in graph. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb96d1cd6665cf4da65a41f580932103"></a><!-- doxytag: member="FIRM::generateControllersWithEdgeCost" ref="acb96d1cd6665cf4da65a41f580932103" args="(ompl::base::State *startNodeState, ompl::base::State *targetNodeState, EdgeControllerType &amp;edgeController, NodeControllerType &amp;nodeController)" -->
virtual <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#acb96d1cd6665cf4da65a41f580932103">generateControllersWithEdgeCost</a> (ompl::base::State *startNodeState, ompl::base::State *targetNodeState, <a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">EdgeControllerType</a> &amp;edgeController, <a class="el" href="class_controller.html">NodeControllerType</a> &amp;nodeController)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the cost of the edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfccb43f41872b8da9a4609c1748d21f"></a><!-- doxytag: member="FIRM::generateEdgeController" ref="abfccb43f41872b8da9a4609c1748d21f" args="(const ompl::base::State *start, const ompl::base::State *target, EdgeControllerType &amp;edgeController)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#abfccb43f41872b8da9a4609c1748d21f">generateEdgeController</a> (const ompl::base::State *start, const ompl::base::State *target, <a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">EdgeControllerType</a> &amp;edgeController)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the edge controller that drives the robot from start to end of edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1856164aa0dba82e6cfad26a4ef5a7fe"></a><!-- doxytag: member="FIRM::generateNodeController" ref="a1856164aa0dba82e6cfad26a4ef5a7fe" args="(const ompl::base::State *state, NodeControllerType &amp;nodeController)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a1856164aa0dba82e6cfad26a4ef5a7fe">generateNodeController</a> (const ompl::base::State *state, <a class="el" href="class_controller.html">NodeControllerType</a> &amp;nodeController)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the node controller that stabilizes the robot to the node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a7ffdc57247b8f40899646195750b6a20">solveDynamicProgram</a> (const Vertex goalVertex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the dynamic program to return a feedback policy.  <a href="#a7ffdc57247b8f40899646195750b6a20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4003d4144f6c32e9eaba79f292ec9ce4"></a><!-- doxytag: member="FIRM::addStateToVisualization" ref="a4003d4144f6c32e9eaba79f292ec9ce4" args="(ompl::base::State *state)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>addStateToVisualization</b> (ompl::base::State *state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d9e316c11b1e2ff52b5ff65996d3a01"></a><!-- doxytag: member="FIRM::sendFeedbackEdgesToViz" ref="a8d9e316c11b1e2ff52b5ff65996d3a01" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>sendFeedbackEdgesToViz</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44321fba1c038c1f43ccfeccf9a1c44c"></a><!-- doxytag: member="FIRM::getUpdatedNodeCostToGo" ref="a44321fba1c038c1f43ccfeccf9a1c44c" args="(Vertex node)" -->
std::pair&lt; typename FIRM::Edge, <br class="typebreak"/>
double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a44321fba1c038c1f43ccfeccf9a1c44c">getUpdatedNodeCostToGo</a> (Vertex node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the new cost to go from a node. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1381ddffa42b0bf2d36dc9c6d9d1da9d"></a><!-- doxytag: member="FIRM::starStrategy_" ref="a1381ddffa42b0bf2d36dc9c6d9d1da9d" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a1381ddffa42b0bf2d36dc9c6d9d1da9d">starStrategy_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the default connection strategy is the Star strategy. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4307c058abb03b3a84c5c60e849c191"></a><!-- doxytag: member="FIRM::sampler_" ref="af4307c058abb03b3a84c5c60e849c191" args="" -->
ompl::base::ValidStateSamplerPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af4307c058abb03b3a84c5c60e849c191">sampler_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampler user for generating valid samples in the state space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af71a0e86b8a99f9eaa687f161d8d68e1"></a><!-- doxytag: member="FIRM::simpleSampler_" ref="af71a0e86b8a99f9eaa687f161d8d68e1" args="" -->
ompl::base::StateSamplerPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#af71a0e86b8a99f9eaa687f161d8d68e1">simpleSampler_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampler user for generating random in the state space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeed6858c0216ed9fc49f02e4aafc4443"></a><!-- doxytag: member="FIRM::nn_" ref="aeed6858c0216ed9fc49f02e4aafc4443" args="" -->
RoadmapNeighbors&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aeed6858c0216ed9fc49f02e4aafc4443">nn_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbors data structure. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac954812b235fc64b57ea319bec7c80bb"></a><!-- doxytag: member="FIRM::g_" ref="ac954812b235fc64b57ea319bec7c80bb" args="" -->
<a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac954812b235fc64b57ea319bec7c80bb">g_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connectivity graph. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a333c7dec34b4c0977f85424b9fc3dc21"></a><!-- doxytag: member="FIRM::startM_" ref="a333c7dec34b4c0977f85424b9fc3dc21" args="" -->
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a333c7dec34b4c0977f85424b9fc3dc21">startM_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of start milestones. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb59b6121e120e14f30c58e567ec6a4c"></a><!-- doxytag: member="FIRM::goalM_" ref="aeb59b6121e120e14f30c58e567ec6a4c" args="" -->
std::vector&lt; Vertex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aeb59b6121e120e14f30c58e567ec6a4c">goalM_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of goal milestones. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f27981600a6b5ee4c5124b8f9bc640b"></a><!-- doxytag: member="FIRM::stateProperty_" ref="a8f27981600a6b5ee4c5124b8f9bc640b" args="" -->
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
<a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a8f27981600a6b5ee4c5124b8f9bc640b">stateProperty_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the internal ompl::base::state at each Vertex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5651af4be68cf84115fbf6fe4b2c958d"></a><!-- doxytag: member="FIRM::totalConnectionAttemptsProperty_" ref="a5651af4be68cf84115fbf6fe4b2c958d" args="" -->
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
<a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a5651af4be68cf84115fbf6fe4b2c958d">totalConnectionAttemptsProperty_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the number of total connection attempts for a vertex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9d31e5b2a0bf5921fb1c8f43e55338b"></a><!-- doxytag: member="FIRM::successfulConnectionAttemptsProperty_" ref="ad9d31e5b2a0bf5921fb1c8f43e55338b" args="" -->
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
<a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ad9d31e5b2a0bf5921fb1c8f43e55338b">successfulConnectionAttemptsProperty_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the number of successful connection attempts for a vertex. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebe2eb302b9af9ced9bc26f03d369297"></a><!-- doxytag: member="FIRM::weightProperty_" ref="aebe2eb302b9af9ced9bc26f03d369297" args="" -->
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
boost::edge_weight_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#aebe2eb302b9af9ced9bc26f03d369297">weightProperty_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the weights of each Edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81eba4eb39bce397127a9d41cf0b5cd2"></a><!-- doxytag: member="FIRM::edgeIDProperty_" ref="a81eba4eb39bce397127a9d41cf0b5cd2" args="" -->
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
boost::edge_index_t &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a81eba4eb39bce397127a9d41cf0b5cd2">edgeIDProperty_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the indices of each Edge. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe52d3e291fc164ff9338765534e7ce"></a><!-- doxytag: member="FIRM::disjointSets_" ref="adbe52d3e291fc164ff9338765534e7ce" args="" -->
boost::disjoint_sets<br class="typebreak"/>
&lt; boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
boost::vertex_rank_t &gt;::type, <br class="typebreak"/>
boost::property_map&lt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">Graph</a>, <br class="typebreak"/>
boost::vertex_predecessor_t &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#adbe52d3e291fc164ff9338765534e7ce">disjointSets_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure that maintains the connected components. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a517174c1ae349153df76f81f2ba2b2f1"></a><!-- doxytag: member="FIRM::maxEdgeID_" ref="a517174c1ae349153df76f81f2ba2b2f1" args="" -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a517174c1ae349153df76f81f2ba2b2f1">maxEdgeID_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum unique id number used so for for edges. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fcb0aef9c9101c4569f5b6bb5f576ae"></a><!-- doxytag: member="FIRM::connectionStrategy_" ref="a0fcb0aef9c9101c4569f5b6bb5f576ae" args="" -->
<a class="el" href="class_f_i_r_m.html#a15cfbcaf52c0bdd5e6c1a969bbf7ea1e">ConnectionStrategy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a0fcb0aef9c9101c4569f5b6bb5f576ae">connectionStrategy_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that returns the milestones to attempt connections with. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ad7ac389f9e8b0e483826833c32da95"></a><!-- doxytag: member="FIRM::connectionFilter_" ref="a0ad7ac389f9e8b0e483826833c32da95" args="" -->
<a class="el" href="class_f_i_r_m.html#a2482eee2e5248d5bff3b3b56e5a593b3">ConnectionFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a0ad7ac389f9e8b0e483826833c32da95">connectionFilter_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that can reject a milestone connection. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42cc77417338d946478f5a71e6bd5b70"></a><!-- doxytag: member="FIRM::userSetConnectionStrategy_" ref="a42cc77417338d946478f5a71e6bd5b70" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a42cc77417338d946478f5a71e6bd5b70">userSetConnectionStrategy_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag indicating whether the employed connection strategy was set by the user (or defaults are assumed) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e91a5d8aba0ccaca892fb9eeda4ef41"></a><!-- doxytag: member="FIRM::rng_" ref="a2e91a5d8aba0ccaca892fb9eeda4ef41" args="" -->
ompl::RNG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a2e91a5d8aba0ccaca892fb9eeda4ef41">rng_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc413ddef9b66cd337c0e19c6ba79d84"></a><!-- doxytag: member="FIRM::addedSolution_" ref="afc413ddef9b66cd337c0e19c6ba79d84" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#afc413ddef9b66cd337c0e19c6ba79d84">addedSolution_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag indicating that a solution has been added during solve() <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae71c316b447bb7b404dc27c8d673fd55"></a><!-- doxytag: member="FIRM::graphMutex_" ref="ae71c316b447bb7b404dc27c8d673fd55" args="" -->
boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ae71c316b447bb7b404dc27c8d673fd55">graphMutex_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex to guard access to the Graph member (g_) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd4f91dc510bf7b5b68b4da5cfd90718"></a><!-- doxytag: member="FIRM::siF_" ref="afd4f91dc510bf7b5b68b4da5cfd90718" args="" -->
const <br class="typebreak"/>
firm::SpaceInformation::SpaceInformationPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#afd4f91dc510bf7b5b68b4da5cfd90718">siF_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base::SpaceInformation cast as <a class="el" href="classfirm_1_1_space_information.html">firm::SpaceInformation</a>, for convenience. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfacc68b478054d0b99a3965d33d718a"></a><!-- doxytag: member="FIRM::edgeControllers_" ref="abfacc68b478054d0b99a3965d33d718a" args="" -->
std::map&lt; Edge, <br class="typebreak"/>
<a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">EdgeControllerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#abfacc68b478054d0b99a3965d33d718a">edgeControllers_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the edge controllers according to the edges. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac80211b920fb34ee04779c9af2c0d1c4"></a><!-- doxytag: member="FIRM::nodeControllers_" ref="ac80211b920fb34ee04779c9af2c0d1c4" args="" -->
std::map&lt; Vertex, <br class="typebreak"/>
<a class="el" href="class_controller.html">NodeControllerType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#ac80211b920fb34ee04779c9af2c0d1c4">nodeControllers_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that stores the node controllers according to the node (vertex) ids. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2da49edf6ea58f4116cd3c31022bd693"></a><!-- doxytag: member="FIRM::costToGo_" ref="a2da49edf6ea58f4116cd3c31022bd693" args="" -->
std::map&lt; Vertex, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>costToGo_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae9e2e83177ef121adc36ef7f9e5d16d"></a><!-- doxytag: member="FIRM::feedback_" ref="aae9e2e83177ef121adc36ef7f9e5d16d" args="" -->
std::map&lt; Vertex, Edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>feedback_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17cff52eb2c31715ab8341b9daea1a3f"></a><!-- doxytag: member="FIRM::numParticles_" ref="a17cff52eb2c31715ab8341b9daea1a3f" args="" -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#a17cff52eb2c31715ab8341b9daea1a3f">numParticles_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of particles to use for monte carlo simulations. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fc88496b950b90b92876dea03b3102f"></a><!-- doxytag: member="FIRM::debug_" ref="a7fc88496b950b90b92876dea03b3102f" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>debug_</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add9de6c5accdea0f9b6d1ff458350036"></a><!-- doxytag: member="FIRM::minFIRMNodes_" ref="add9de6c5accdea0f9b6d1ff458350036" args="" -->
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_i_r_m.html#add9de6c5accdea0f9b6d1ff458350036">minFIRMNodes_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum number of nodes that should be sampled. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Feedback Information RoadMap planner. </p>
<p><a class="anchor" id="FIRM"></a> </p>
<dl class="user"><dt><b>Short description</b></dt><dd>Feedback Information RoadMap is a method that generates a graph in belief space and returns a policy that guides that robot from the start to goal.</dd></dl>
<dl class="user"><dt><b>External documentation</b></dt><dd>A. Agha-mohammadi, Suman Chakravorty, Nancy Amato, "FIRM: Sampling-based Feedback Motion Planning Under Motion 
   Uncertainty and Imperfect Measurements", International Journal of Robotics Research, 33(2):268-304, February 2014</dd></dl>
<p><a href="http://www.mit.edu/~aliagha/Web/pubpdfs/2014.Ali.Suman.ea.IJRR_FIRM.pdf">[PDF]</a> </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a70abcb24fbc9f836b94119f65c8f8a37"></a><!-- doxytag: member="FIRM::EdgeControllerType" ref="a70abcb24fbc9f836b94119f65c8f8a37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_controller.html">Controller</a>&lt;<a class="el" href="class_r_h_c_i_create.html">RHCICreate</a>, <a class="el" href="class_extended_k_f.html">ExtendedKF</a>&gt; <a class="el" href="class_f_i_r_m.html#a70abcb24fbc9f836b94119f65c8f8a37">FIRM::EdgeControllerType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defining the edge and node controller types </p>

</div>
</div>
<a class="anchor" id="a687e9f4243b22c30ee1fa5da22a85053"></a><!-- doxytag: member="FIRM::Graph" ref="a687e9f4243b22c30ee1fa5da22a85053" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::adjacency_list&lt; boost::vecS, boost::vecS, boost::bidirectionalS, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__state__t.html">vertex_state_t</a>, ompl::base::State*, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__total__connection__attempts__t.html">vertex_total_connection_attempts_t</a>, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__successful__connection__attempts__t.html">vertex_successful_connection_attempts_t</a>, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1vertex__flags__t.html">vertex_flags_t</a>, unsigned int, boost::property &lt; boost::vertex_predecessor_t, unsigned long int, boost::property &lt; boost::vertex_rank_t, unsigned long int &gt; &gt; &gt; &gt; &gt; &gt;, boost::property &lt; boost::edge_weight_t, <a class="el" href="class_f_i_r_m_weight.html">FIRMWeight</a> , boost::property &lt; boost::edge_index_t, unsigned int, boost::property &lt; <a class="el" href="struct_f_i_r_m_1_1edge__flags__t.html">edge_flags_t</a>, unsigned int &gt; &gt; &gt; &gt; <a class="el" href="class_f_i_r_m.html#a687e9f4243b22c30ee1fa5da22a85053">FIRM::Graph</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The underlying roadmap graph. </p>
<dl class="user"><dt><b>Edges are directed and have a weight property called FIRMWeight. This weight property</b></dt><dd>stores information about the edge controller identification, transition probability and execution cost. </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4c909fc53ceeeecb6992ccebf0ab60d6"></a><!-- doxytag: member="FIRM::checkForSolution" ref="a4c909fc53ceeeecb6992ccebf0ab60d6" args="(const ompl::base::PlannerTerminationCondition &amp;ptc, ompl::base::PathPtr &amp;solution)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_i_r_m.html#a4c909fc53ceeeecb6992ccebf0ab60d6">FIRM::checkForSolution</a> </td>
          <td>(</td>
          <td class="paramtype">const ompl::base::PlannerTerminationCondition &amp;&#160;</td>
          <td class="paramname"><em>ptc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ompl::base::PathPtr &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Thread that checks for solution </p>

</div>
</div>
<a class="anchor" id="a28ff922dfb8df66dbb82a6b6078959a0"></a><!-- doxytag: member="FIRM::constructFeedbackPath" ref="a28ff922dfb8df66dbb82a6b6078959a0" args="(const Vertex &amp;start, const Vertex &amp;goal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ompl::base::PathPtr <a class="el" href="class_f_i_r_m.html#a28ff922dfb8df66dbb82a6b6078959a0">FIRM::constructFeedbackPath</a> </td>
          <td>(</td>
          <td class="paramtype">const Vertex &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vertex &amp;&#160;</td>
          <td class="paramname"><em>goal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given two milestones from the same connected component, construct a path connecting them and set it as the solution. </p>
<p>Given a solution represented as a vector of predecesors in the roadmap, construct a geometric path</p>
<p>ompl::base::PathPtr FIRM::constructSolution(const Vertex &amp;start, const Vertex &amp;goal) {</p>
<p>} </p>

</div>
</div>
<a class="anchor" id="a3f85ba51a7c3b62b75df7f7c16064cec"></a><!-- doxytag: member="FIRM::setConnectionFilter" ref="a3f85ba51a7c3b62b75df7f7c16064cec" args="(const ConnectionFilter &amp;connectionFilter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_i_r_m.html#a3f85ba51a7c3b62b75df7f7c16064cec">FIRM::setConnectionFilter</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_i_r_m.html#a2482eee2e5248d5bff3b3b56e5a593b3">ConnectionFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>connectionFilter</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the function that can reject a milestone connection. </p>
<dl class="user"><dt><b>The given function is called immediately before a connection</b></dt><dd>is checked for collision and added to the roadmap. Other neighbors may have already been connected before this function is called. This allows certain heuristics that use the structure of the roadmap (like connected components or useful cycles) to be implemented by changing this function.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">connectionFilter</td><td>A function that takes the new milestone, a neighboring milestone and returns whether a connection should be attempted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8017d1847e682f39c2cbce33e904af57"></a><!-- doxytag: member="FIRM::setConnectionStrategy" ref="a8017d1847e682f39c2cbce33e904af57" args="(const ConnectionStrategy &amp;connectionStrategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_i_r_m.html#a8017d1847e682f39c2cbce33e904af57">FIRM::setConnectionStrategy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_f_i_r_m.html#a15cfbcaf52c0bdd5e6c1a969bbf7ea1e">ConnectionStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>connectionStrategy</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the connection strategy function that specifies the milestones that connection attempts will be made to for a given milestone. </p>
<dl class="user"><dt><b>The behavior and performance of PRM can be changed drastically</b></dt><dd>by varying the number and properties of the milestones that are connected to each other.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pdef</td><td>A function that takes a milestone as an argument and returns a collection of other milestones to which a connection attempt must be made. The default connection strategy is to connect a milestone's 10 closest neighbors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ffdc57247b8f40899646195750b6a20"></a><!-- doxytag: member="FIRM::solveDynamicProgram" ref="a7ffdc57247b8f40899646195750b6a20" args="(const Vertex goalVertex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_f_i_r_m.html#a7ffdc57247b8f40899646195750b6a20">FIRM::solveDynamicProgram</a> </td>
          <td>(</td>
          <td class="paramtype">const Vertex&#160;</td>
          <td class="paramname"><em>goalVertex</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves the dynamic program to return a feedback policy. </p>
<p>--NOTES-- Assign a high cost to go initially for all nodes that are not in the goal connected component. For nodes that are in the goal cc, we assign goal cost to go for the goal and init cost to go for all other nodes.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/Planner/<a class="el" href="_f_i_r_m_8h_source.html">FIRM.h</a></li>
<li>src/Planner/FIRM.cpp</li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 31 2014 13:00:50 for FIRM-OMPL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
