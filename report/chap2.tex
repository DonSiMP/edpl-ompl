\chapter{Issues \& Notes}

\section{Notes}

OMPLâ€™s API is very different programmatically and philosophically from PMPL. Due to its lightweight nature, OMPL does not depend 
external libraries (except BOOST) which gives it a disadvantage in terms of extra functionality (such as reading setup parameters from XML files etc.).

\subsection{How the OMPL PRM planner works}
\begin{enumerate}
 \item Call \textit{setProblemDefinition} to define the parameters of the problem.
 \item Call \textit{setup} to setup the planners specific internals like validity checker etc.
 \item  Call \textit{solve} to find construct graph and find a solutions:
  \begin{enumerate}
    \item Call \textit{checkValidity} : makes sure start and goal states have been set
    \item set termination conditions
    \item Call \textit{constructRoadMap}: 
	    \begin{itemize}
	     \item Allocates a simple state sampler
	     \item Calls \textit{growRoadmap} and \textit{expandRoadmap} in a 2:1 ratio
	    \end{itemize}
  \end{enumerate}

 \item \textit{addMilestone} : 
  \begin{enumerate}
   \item  Adds a state to the graph and creates a vertex with the properties and everything else. 
   \item After creating the vertex, it attempts to connect the vertex to its nearest neighbours
   \item during the connection, it finds the motion cost associated with the connection. \color{red}{This is the point where we run the monte carlo simulation to generate edge costs}
  \end{enumerate}

 \item \textit{growRoadmap}: Takes as input a termination condition and a state, samples a valid state and puts it in input state and adds it to the graph.
\end{enumerate}

\subsection{Sampling a valid belief}

\begin{enumerate}
 \item While sampling we need to check if a state is in collision and observable. 
 \item The collision check is done by validitychecker. 
 \item The observability check can be done by filter or observation model (currently chosen).
 \item If sampled state passes all checks, we need to construct its stationary belief.
\end{enumerate}


\subsection{State Validity Checking}
Can code be simply re-used, is there any need to write a new validitychecker? 

\begin{itemize}
 \item We need to check for collision. Can use the provided FCL wrapper in OMPL.
 \item The observability check is also done through validitychecker because the information about space should be accessed through the space information.
 \item 
\end{itemize}

\subsection{SpaceInformation Class}

This requires us to set:
\begin{enumerate}
 \item ValidityChecker
 \item MotionChecker
 \item Sampler
\end{enumerate}

\subsection{The OMPL MotionValidator class}

\begin{enumerate}
 \item Checks if the intermediate states between start and end states are valid. Is basically the localplanner.
 \item Should we add the monte carlo simulation to this class or keep our own MotionModelLP to do that.
\end{enumerate}

\subsection{Using the Control Space}

\begin{itemize}
 \item OMPL defines a control space and we must use RealVectorControl instead of armadillo (old pmpl implementation). So need to change how we use \textcolor{red}{ControlType}. Instead of colvec it should use the OMPL stuff. 
 
 \item An instance of a \textbf{StatePropagator} class is to be defined in controlspace. Its job is to propagate the state of a robot based on control input. We need to  derive      our motion model from this class. 

 \end{itemize}



\subsection{Modifications required to OMPL PRM}

\begin{enumerate}
 \item In the function \textit{addMilestone}:
  \begin{enumerate}
   \item Check if a state is observable before adding it to the graph - \textcolor{red}{I think the \textit{GaussianValidBeliefSampler} should check the observability for a sample, whether to actually put the observability check in filter or observation model needs to be decided} 
   \item Call localplanner to run the monte carlo simulation and generate edge costs
   \item 
  \end{enumerate}

  \item Should the motionmodel and observationmodel be provided to the planner or to problemdefinition (like pmpl)?
\end{enumerate}


\section{Issues}
Log of issues faced and discussions on their solutions.

\begin{enumerate}
 \item Should the optimization functionality in OMPL Planner class be used or should the planner be implemented straight forward, similar to PMPL approach ?
    \begin{itemize}
     \item 
    \end{itemize}
\item How to add the properties of an edge to the graph i.e. EdgeController; a) Create a hashtable which maps from edge to controller id, b) store the edge controller as the property of an edge i.e. create a custom edge property. Easier approach would be to (a).

 \item What is the job of the validitychecker ? -> to check if a state is in collision or not. 

\end{enumerate}
